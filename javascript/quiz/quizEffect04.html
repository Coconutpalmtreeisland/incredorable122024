<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>퀴즈 이펙트04</title>

    <style>
        .quiz__score {
            position: fixed;
            left: 10px;
            bottom: 10px;
            width: 70px;
            height: 50px;
            line-height: 50px;
            border-radius: 10px;
            background-color: #412e91;
            color: #fff;
            text-align: center;
            font-size: 20px;
        }
    </style>
    <link rel="stylesheet" href="assets/css/quiz.css">
    <link rel="stylesheet" href="assets/css/ani.css">
</head>
<body>
    <header id="header">
        <h1>
            <a href="../index.html">Quiz</a>
        </h1>
        <nav>
            <ul>
                <li><a href="quizEffect01.html">1</a></li>
                <li><a href="quizEffect02.html">2</a></li>
                <li><a href="quizEffect03.html">3</a></li>
                <li class="active"><a href="quizEffect04.html">4</a></li>
                <li><a href="quizEffect05.html">5</a></li>
                <li><a href="quizEffect06.html">6</a></li>
                <li><a href="quizEffect07.html">7</a></li>
                <li><a href="quizEffectI.html">I</a></li>
                <li><a href="quizEffectW.html">W</a></li>
            </ul>
        </nav>
    </header>
    <!-- //header -->

    <main id="main">
        <div class="quiz__wrap"></div>
        <div class="quiz__score"></div>
    </main>
    <!-- //main -->

    <footer id="footer">
        <a href="mailto:webstoryboy@naver.com">webstoryboy@naver.com</a>
    </footer>
    <!-- //footer -->

    <script>
        // 선택자 
        const quizWrap = document.querySelector(".quiz__wrap"); 
        const quizScore = document.querySelector(".quiz__score");
        let totalScore = 0; 

        // 문제 정보
        const quizInfo = [
            {
                infoDate : "2020년 4회",
                infoType : "정보처리 기능사",
                infoQuestion : "이항(binary) 연산에 해당하는 것은?",
                infoChoice : {
                    1: "COMPLEMENT",
                    2: "AND",
                    3: "ROTATE",
                    4: "SHIFT"
                },
                infoAnswer : "2",
                infoDesc : "단항연산 : ROTATE, SHIFT, MOVE, NOT(COMPLEMENT)"
            },
            {
                infoDate : "2020년 4회",
                infoType : "정보처리 기능사",
                infoQuestion : "로더(Loader)가 수행하는 기능으로 옳지 않은 것은?",
                infoChoice : {
                    1: "재배치가 가능한 주소들을 할당된 기억 장치에 맞게 변환한다.",
                    2: "로드 모듈은 주기억 장치로 읽어 들인다.",
                    3: "프로그램의 수행 순서를 결정한다.",
                    4: "프로그램을 적재할 주기억 장치 내의 공간을 할당한다.",
                },
                infoAnswer : "3",
                infoDesc : "로더는 기계어로 번역된 목적프로그램을 주기억 장치에 적재하여 실행할 수 있도록 해주는 시스템 프로그램입니다. 로더의 기능은 할당(Allocation), 연결(Linking), 재배치(Relocation), 적재(Loadiing) 등이 있습니다."
            },
            {
                infoDate : "2006년 5회",
                infoType : "정보처리 기능사",
                infoQuestion : "제어장치가 앞의 명령 실행을 완료한 후, 다음에 실행 할 명령을 기억장치로부터 가져오는 동작을 완료할 때까지의 주기를 무엇이라고 하는가?",
                infoChoice : {
                    1: "fetch cycle",
                    2: "transfer cycle",
                    3: "search time",
                    4: "run time"
                },
                infoAnswer : "1",
                infoDesc : "명령어를 가지고 오는것을 fetch cycle 이라고 합니다."
            },
            {
                infoDate : "2021년 1회",
                infoType : "정보처리기능사",
                infoQuestion : "특정 값을 여러 자리인 2진수로 변환하거나 특정 장치로부터 보내오는 신호를 여러 개의 2진 신호로 바꾸어 변환시키는 장치는?",
                infoChoice : {
                    1: "인코더(Encoder)",
                    2: "디코더(Decoder)",
                    3: "멀티플렉서(Multiplexer)",
                    4: "플립플롭(Flip-Flop)",
                },
                infoAnswer : "1",
                infoDesc : "인코더는 2의 n승개의 입력을 받아들여 n개의 데이터를 출력하고 OR게이트로 구성되며 부호기라고 합니다.",
            },
            {
                infoDate : "2017년 상시",
                infoType : "정보처리기능사",
                infoQuestion : "명령어 구성에서 연산자의 기능에 해당하지 않는 것은?",
                infoChoice : {
                    1: "입출력 기능",
                    2: "주소 지정 기능",
                    3: "제어 기능",
                    4: "함수 연산 기능",
                },
                infoAnswer : "2",
                infoDesc : "연산자(OP-Code)의 기능: 함수 연산 기능, 전달 기능, 제어 기능, 입출력 기능",
            },
            {
                infoDate : "2020년 4회",
                infoType : "정보처리기능사",
                infoQuestion : "다음 중 컴퓨터의 기종에 관계없이 프로그램이 수행될 수 있는 성질을 의미하는 것은",
                infoChoice : {
                    1: "가용성",
                    2: "신뢰성",
                    3: "호환성",
                    4: "안정성",
                },
                infoAnswer : "3",
                infoDesc : "호환성은 서로 다른 컴퓨터 간에도 프로그램이나 자료의 공유가 가능한 것을 말합니다.",
            },
            {
                infoDate : "2020년 2회",
                infoType : "정보처리기능사",
                infoQuestion : "정보 처리 속도 단위 중 초당 100만 개의 연산을 수행한다는 의미의 단위는?",
                infoChoice : {
                    1: "MIPS",
                    2: "KIPS",
                    3: "MFLOPS",
                    4: "LIPS",
                },
                infoAnswer : "1",
                infoDesc : "KIPS는 1초동안 1,000개의 연산을 수행합니다. MFLOPS는 초당 1백만 회 수항 가능한 부동 소수점 연산입니다. LIPS는 1초 동안 실행 가능한 논리적 추론 횟수입니다.",
            },
            {
                infoDate : "2021년 1회",
                infoType : "정보처리기능사",
                infoQuestion : "레지스터에 새로운 데이터를 전송하면 먼저 있던 내용은 어떻게 되는가?",
                infoChoice : {
                    1: "기억된 내용에 아무런 변화가 없다.",
                    2: "먼저 내용은 지워지고 새로운 내용만 기억된다.",
                    3: "먼저 내용은 다른 곳으로 전송되고 새로운 내용만 기억된다.",
                    4: "누산기(Accumulator)에서 덧셈이 이루어진다.",
                },
                infoAnswer : "2",
                infoDesc : "레지스터(Register)는 연산의 결과나 처리할 명령을 기억하는 고속의 임시 기억 장치로 새로운 데이터가 전송되면 전송된 내용만 기억합니다.",
            },
            {
                infoDate : "2019년 상시",
                infoType : "정보처리기능사",
                infoQuestion : "현재 수행 중에 있는 명령어 코드(Code)를 저장하고 있는 임시 저장 장치는?",
                infoChoice : {
                    1: "인덱스 레지스터(Index Register)",
                    2: "누산기(Accumulator)",
                    3: "명령 레지스터(Instruction Register)",
                    4: "메모리 레지스터(Memory Register)",
                },
                infoAnswer : "3",
                infoDesc : "명령 레지스터(IR)는 현재 수행 중인 명령어를 보관합니다. 인덱스 레시스터는 인덱스 주소 지정시 사용하는 레지스터입니다. 누산기는 연산 장치의 핵심 레지스터로서 산술 및 논리 연산의 결과를 일시적으로 기억하는 장치입니다.",
            },
            {
                infoDate : "2021년 2회",
                infoType : "정보처리기능사",
                infoQuestion : "컴퓨터의 중앙 처리 장치(CPU) 구성 부분에 해당되지 않는 것은?",
                infoChoice : {
                    1: "주기억 장치",
                    2: "연산 장치",
                    3: "보조 기억 장치",
                    4: "제어 장치",
                },
                infoAnswer : "3",
                infoDesc : "중앙 처리 장치(CPU)는 제어 장치, 주기억 장치, 연산 장치로 구성되어 있습니다. 주변 장치는 입력 장치, 출력 장치, 보조 기억 장치로 구성되어 있습니다.",
            },
            {
                infoDate : "2020년 3회",
                infoType : "정보처리기능사",
                infoQuestion : "[논리 회로, 누산기, 가산기, 보수기]와 관계 있는 장치는?",
                infoChoice : {
                    1: "연산 장치",
                    2: "기억 장치",
                    3: "제어 장치",
                    4: "보조 기억 장치",
                },
                infoAnswer : "1",
                infoDesc : "연산 장치에서 사용되는 레지스터는 누산기, 데이터 레지스터, 가산기, 상태 레지스터, 보수기가 있습니다. 제어 장치에서 사용되는 레시스터는 프로그램 카운터, 명령 레지스터, 명령 해독기, 번지 해독기, 부호기, 기억 번지 레지스터, 기억 버퍼 레지스터가 있습니다.",
            },
            {
                infoDate : "2021년 1회/2회",
                infoType : "정보처리기능사",
                infoQuestion : "다음 중 기억 장치로부터 읽혀지거나 기록할 자료를 임시로 보관하는 Register는?",
                infoChoice : {
                    1: "PC(Program Counter)",
                    2: "MAR(Memory Address Register)",
                    3: "IR(Instrution Register)",
                    4: "MBR(Memory Buffer Register)",
                },
                infoAnswer : "4",
                infoDesc : "기억 레지스터(MBR)는 주기억 장치에서 연산에 필요한 자료를 호출하여 저장합니다. 프로그램 카운터(PC)는 다음에 수행할 명령어의 번지를 기억합니다. 번지 레스터(MAR)는 주기억 장치의 번지를 기억합니다. 명령 레스터(IR)는 현재 수행 중인 명령어의 내용을 기억합니다.",
            },
            {
                infoDate : "2020년 4회",
                infoType : "정보처리기능사",
                infoQuestion : "다음 중 입력이 어느 하나라도 1이면 출력이 1일 되고, 입력이 모두 0일 때만 출력이 0이 되는 게이트는?",
                infoChoice : {
                    1: "NOT",
                    2: "AND",
                    3: "OR",
                    4: "XOR",
                },
                infoAnswer : "3",
                infoDesc : "OR 게이트는 두개의 입력값 중 하나 이상 1이면 출력값이 1이 됩니다(병렬회로). NOT은 입력값의 반대값이 출력됩니다. AND 두 개의 입력값이 모두 1일 때만 출력값이 1이 됩니다(직력회로). XOR은 둘 중 하나의 값이 1일 때만(서로 다를 때) 출력값이 1이 됩니다.",
            },
            {
                infoDate : "2021년 1회",
                infoType : "정보처리기능사",
                infoQuestion : "전가산기에 대한 설명 중 옳은 것은?",
                infoChoice : {
                    1: "1개의 반가산기와 1개의 OR 회로로 구성된다.",
                    2: "1개의 반가산기와 1개의 AND 회로로 구성된다.",
                    3: "2개의 반가산기와 1개의 OR 회로로 구성된다.",
                    4: "2개의 반가산기와 1개의 AND 회로로 구성된다.",
                },
                infoAnswer : "3",
                infoDesc : "전가산기(FA; Full Adder)는 2개의 반가산기와 1개의 OR 게이트로 구성됩니다.",
            },
            {
                infoDate : "2021년 2회",
                infoType : "정보처리기능사",
                infoQuestion : "반가산기(Half-Adder)의 논리 회로도에서 자리올림이 발생하는 회로는?",
                infoChoice : {
                    1: "OR",
                    2: "NOT",
                    3: "eXclusive-OR",
                    4: "AND",
                },
                infoAnswer : "4",
                infoDesc : "진리표에 의해 합(Sum)은 배타적 논리합(eXclusive-OR) Gate의 진리값이고, 자리올림수(Carry)는 논리곱(AND)의 진리값과 같습니다.",
            },
            {
                infoDate : "2020년 4회",
                infoType : "정보처리기능사",
                infoQuestion : "1비트(bit)를 기억할 수 있는 능력을 가진 기억의 최소 단위로 클록이 있는 순서 회로에 기억된 기억 소자는?",
                infoChoice : {
                    1: "플립플롭(Flip-Flop)",
                    2: "전가산기(Full Adder)",
                    3: "반가산기(Half Adder)",
                    4: "부호기(Encoder)",
                },
                infoAnswer : "1",
                infoDesc : "플립플롭은 1비트('0' 또는 '1')의 정보를 기억할 수 있는 최소의 기억 소자로 RS 플립플롭, JK 플립플롭, D 플립플롭, T 플립플롭 등이 있습니다. 전가산기는 두 비트와 전 상태의 자리올림수를 더한 게이트로 구성됩니다. 반가산기는 2진수 1자리의 A와 B를 더한 합과 자리올림수를 얻는 회로, AND 회로, XOR 회로로 구성됩니다. 부호기는 2의 n승개의 입력을 받아들여 n개의 데이터를 출력하는 회로로 OR 게이트로 구성됩니다.",
            },
            {
                infoDate : "2020년 2회",
                infoType : "정보처리기능사",
                infoQuestion : "JK 플립플롭에서 보수가 출력되기 위한 J, K의 입력 상태는?",
                infoChoice : {
                    1: "J=1, K=0",
                    2: "J=0, K=1",
                    3: "J=1, K=1",
                    4: "J=0, K=0",
                },
                infoAnswer : "3",
                infoDesc : "JK 플립플롭은 J=k=1이 되면 보수(반전), J=k=0이면 전 상태 불변이 됩니다.",
            },
            {
                infoDate : "2021년 1회",
                infoType : "정보처리기능사",
                infoQuestion : "누를 때마다 ON,OFF가 교차되는 스위치를 만들고자 할 때 사용되는 플립플롭은?",
                infoChoice : {
                    1: "RS 플립플롭",
                    2: "D 플립플롭",
                    3: "JK 플립플롭",
                    4: "T 플립플롭",
                },
                infoAnswer : "4",
                infoDesc : "T 플립플롭은 입력이 '0'이 되면 전 상태 불변, 입력이 '1'이면 전 상태의 보수값이 됩니다. RS 플립플롭은 Reset 단자와 Set 단자의 신호에 따라 2진수를 1자리를 기억합니다. D 플립플롭은 한 개의 입력을 가지며, RS 플립플롭에 NOT 게이트를 추가해서 구현할 수 있습니다. JK 플립플롭은 모든 플립플롭의 기능을 대용할 수 있으므로 응용 범위가 넓고 집적회로화되어 가장 널리 사용됩니다.",
            },
            {
                infoDate : "2021년 2회",
                infoType : "정보처리기능사",
                infoQuestion : "다음 중 가장 작은 수는?",
                infoChoice : {
                    1: "2진수 101011000",
                    2: "8진수 531",
                    3: "10진수 345",
                    4: "16진수 159",
                },
                infoAnswer : "1",
                infoDesc : "2진수: 1X2**8 + 0X2**7 + 1X2**6 + 0X2**5 + 1X2**4 + 1X2**3 + 0X2**2 + 0X2**1 + 0X2**0 = 344, 8진수: 5X8**2 + 3X8**1 + 1X8**0 = 345, 10진수 = 345, 16진수: 1X16**2 + 5X16**1 + 9X16**0 = 345",
            },
            {
                infoDate : "2020년 3회",
                infoType : "정보처리기능사",
                infoQuestion : "다음 중 컴퓨터 시스템에서 처리할 경우 연산 속도가 가장 빠른 것은?",
                infoChoice : {
                    1: "S = A / B",
                    2: "S = A + B",
                    3: "S = A - B",
                    4: "S = A x B",
                },
                infoAnswer : "2",
                infoDesc : "사칙 연산 중 덧셈 연산은 중간 연산 과정이 필요하지 않으므로 연산 속도가 가장 빠릅니다.",
            },
            {
                infoDate : "2021년 1회",
                infoType : "정보처리기능사",
                infoQuestion : "2진수 (10001010)를 2의 보수로 옳게 표현한 것은?",
                infoChoice : {
                    1: "01110101",
                    2: "01110110",
                    3: "10001011",
                    4: "10000110",
                },
                infoAnswer : "2",
                infoDesc : "2의 보수 = 1의 보수 + 1, 10001010 -> 01110101 + 1 -> 01110110",
            },
            {
                infoDate : "2021년 1회",
                infoType : "정보처리기능사",
                infoQuestion : "2진수 (101010101010)을 10진수로 변환하면?",
                infoChoice : {
                    1: "2730",
                    2: "2630",
                    3: "2740",
                    4: "2640",
                },
                infoAnswer : "1",
                infoDesc : "1x2**11 + 1x2**10 + 1x2**9 + 1x2**8 + 1x2**7 + 1x2**6 + 1x2**5 + 1x2**4 + 1x2**3 + 1x2**2 + 1x2**1 + 1x2**0 = 2048 + 0 + 512 + 0 + 128 + 0 + 32 + 0 + 8 + 0 + 2 + 0 = 2730",
            },
            {
                infoDate : "2020년 3회",
                infoType : "정보처리기능사",
                infoQuestion : "16진수 2C를 10진수로 변환한 것으로 옳은 것은?",
                infoChoice : {
                    1: "41",
                    2: "42",
                    3: "43",
                    4: "44",
                },
                infoAnswer : "4",
                infoDesc : "16진수 2C를 10진수로 변환 = 2x16**1 + C(12) + 16**0 = 32 = 12 = 44",
            },
            {
                infoDate : "2020년 4회",
                infoType : "정보처리기능사",
                infoQuestion : "EBCDIC 코드는 몇 개의 Zone Bit를 갖는가?",
                infoChoice : {
                    1: "1",
                    2: "2",
                    3: "3",
                    4: "4",
                },
                infoAnswer : "4",
                infoDesc : "EBCDIC 코드(Extended BCD Interchange Code : 확장 2진화 10진 코드)는 Zone, Digit 각각 4비트로 구성되어 2**8(=256)가지의 표현이 가능합니다.",
            },
            {
                infoDate : "2020년 2회",
                infoType : "정보처리기능사",
                infoQuestion : "2진수 0110을 그레이 코드로 변환하면?",
                infoChoice : {
                    1: "0010",
                    2: "0111",
                    3: "1010",
                    4: "1110",
                },
                infoAnswer : "3",
                infoDesc : "2진수를 그레이 코드로 변환: 최상위 비트값은 변화 없이 그대로 내려씁니다. 두번째 부터는 인접한 값끼리 XOR 연산한 값을 내려씁니다.",
            },
            {
                infoDate : "2018년 상시",
                infoType : "정보처리기능사",
                infoQuestion : "에러를 검출하고 검출된 에러를 교정하기 위하여 사용되는 코드는?",
                infoChoice : {
                    1: "ASCII 코드",
                    2: "BCD 코드",
                    3: "8421 코드",
                    4: "Hamming 코드",
                },
                infoAnswer : "4",
                infoDesc : "해밍 코드(Hamming Code)는 에러 검출과 에러 교정이 가능하며, 일반적으로 8421 코드에 3비트의 짝수 패리티를 추가하여 구성합니다.",
            },
            {
                infoDate : "2016년 4회",
                infoType : "정보처리기능사",
                infoQuestion : "연속되는 2개의 숫자를 표현한 코드에서 한 개의 비트를 변경하면 새로운 코드가 되기 때문에 아날로그 디지털 변환, 데이터 전ㅅ공 등에 주로 사용되는 코드는?",
                infoChoice : {
                    1: "EBCDIC Code",
                    2: "Hamming Code",
                    3: "ASCII Code",
                    4: "Gray Code",
                },
                infoAnswer : "4",
                infoDesc : "그레이 코드(Gray Code)는 비가중치 코드 중의 하나로, 아날로그/디지털 코드 변환기나 입출력 장치 코드로 많이 사용합니다. 해밍코드는 에러 검출과 에러 교정이 가능하며, 일반적으로 8421 코드에 3비트의 짝수 패리티를 추가하여 구성합니다. EBCDIC 코드는 8비트 코드로, 2**8(256)개의 서로 다른 정보를 표현합니다. ASCII 코드는 7비트 코드로, 2**7(128)개의 서로 다른 정보를 표현합니다.",
            },
            {
                infoDate : "2020년 2회",
                infoType : "정보처리기능사",
                infoQuestion : "주기억 장치에서 자료 표현의 최소 단위는?",
                infoChoice : {
                    1: "블록(Block)",
                    2: "바이트(Byte)",
                    3: "셀(Cell)",
                    4: "레코드(Record)",
                },
                infoAnswer : "2",
                infoDesc : "바이트는 주기억 장치의 자료 표현 최소 단위입니다.",
            },
            {
                infoDate : "2015년 상시",
                infoType : "정보처리기능사",
                infoQuestion : "하나의 레지스터에 기억된 자료를 모두 다른 레지스터로 옮길 때 사용하는 논리 연산은?",
                infoChoice : {
                    1: "Rotate",
                    2: "Shift",
                    3: "Move",
                    4: "Complement",
                },
                infoAnswer : "3",
                infoDesc : "연산의 종류: Rotate = 되돌리기 연산, Shift = 곱셈, 나눗셈에 이용되는 밀치기 연산, Move= 자료의 이동, Complement = 보수,",
            },
            {
                infoDate : "2020년 2회",
                infoType : "정보처리기능사",
                infoQuestion : "8비트짜리 레지스터 A와 B에 각각 '11010101'과 '11110000'이 들어있다. 레지스터 A의 내용이 '00100101'로 바뀌었다면 두 레지스터 A, B 사이에 수행된 논리 연산은?",
                infoChoice : {
                    1: "eXclusive-OR 연산",
                    2: "AND 연산",
                    3: "OR 연산",
                    4: "NOR 연산",
                },
                infoAnswer : "1",
                infoDesc : "XOR 연산은 두 수가 서로 다른 경우 결과값이 1이 됩니다., AND 연산은 특정한 비트를 삭제하는 연산입니다. OR 연산은 일부 데이터를 추가할 때 사용하는 연산입니다.",
            },
            {
                infoDate : "2016년 4회",
                infoType : "정보처리기능사",
                infoQuestion : "명령어(Instruction) 설계 시 고려할 사항으로 옳지 않은 것은?",
                infoChoice : {
                    1: "컴파일러 기술의 사용",
                    2: "메모리 접근 횟수 감소",
                    3: "많은 범용 레지스터의 사용",
                    4: "제한적이고 복잡한 명령어 세트",
                },
                infoAnswer : "4",
                infoDesc : "명령어 설계 시 복잡한 명령어 세트에 대한 부분은 고려 대상에 해당되지 않습니다.",
            },
            {
                infoDate : "2021년 2회",
                infoType : "정보처리기능사",
                infoQuestion : "명령어 형식(Instruction Format)에서 첫번째 바이트에 기억되는 것은?",
                infoChoice : {
                    1: "Operand",
                    2: "Length",
                    3: "Question Mark",
                    4: "OP-Code",
                },
                infoAnswer : "4",
                infoDesc : "명령어의 형식은 명령 코드부(OP-Code)와 번지부(Operand)로 구성됩니다.",
            },
            {
                infoDate : "2015년 상시",
                infoType : "정보처리기능사",
                infoQuestion : "기억 장치에 엑세스(Access)할 필요 없이 스택(Stack)을 이용하여 연산을 행하는 명령어 형식은?",
                infoChoice : {
                    1: "0-주소 명령어",
                    2: "1-주소 명령어",
                    3: "2-주소 명령어",
                    4: "3-주소 명령어",
                },
                infoAnswer : "1",
                infoDesc : "0-주소 형식(=스택 구조)은 명령어에 오퍼랜드부가 없이 데이터가 명령어 자체에 있는 방식으로 스택(Stack) 구조의 컴퓨터에서 사용합니다.(번지가 묵시적으로 지정). 1-주소 형식(=ACC(누산기) 구조)은 주소(오퍼랜드부)가 하나 존재합니다. 2-주소 형식(=범용 레지스터 구조)은 주소부가 2개인 가장 일반적인 형식입니다. 3-주소 형식(=범용 레지스터 구조)은 명령어에 오퍼랜드부가 3개 존재하므로 원래의 값이 보존됩니다.",
            },
            {
                infoDate : "2020년 2회",
                infoType : "정보처리기능사",
                infoQuestion : "기억 장치 고유의 번지로서 0, 1, 2, 3, 등과 같이 16진수로 약속하여 순서대로 정해 좋은 번지, 즉 기억 장치 중의 기억 장소를 지접 숫자로 지정하는 주소로서 기계어 정보가 기억되어 있는 곳은?",
                infoChoice : {
                    1: "메모리 주소(Memory Address)",
                    2: "베이스 주소(Base Address)",
                    3: "상대 주소(Relative Address)",
                    4: "절대 주소(Absolute Address)",
                },
                infoAnswer : "4",
                infoDesc : "절대 주소는 기억 장치 고유의 번지로 16진수 0, 1, 2, 3 등과 같이 순서대로 정해 놓은 번지를 말합니다.",
            },
            {
                infoDate : "2020년 2회",
                infoType : "정보처리기능사",
                infoQuestion : "주소 부분에 있는 값이 실제 데이터가 있는 실제 기억 장치 내의 주소를 나타내며, 단순한 변수 등을 액세스 하는 데 사용되는 주소 지정 방식은?",
                infoChoice : {
                    1: "상대 Address",
                    2: "절대 Address",
                    3: "간접 Address",
                    4: "직접 Address",
                },
                infoAnswer : "4",
                infoDesc : "직접 주소는 주소 부분에 있는 값이 실제 데이터가 있는 주기억 장치 내의 주소를 나타냅니다. 메모리 참조 횟수는 1회입니다., 상대 주소는 별도로 지정된 번지르 기준으로 하여 상태적으로 나타내는 번지입니다. 간전 주소는 명령어의 주소 부분으로 지정한 기억 장소의 내용이 실제 데이터가 있는 곳의 주소로 사용됩니다.",
            },
            {
                infoDate : "2020년 3회",
                infoType : "정보처리기능사",
                infoQuestion : "명령어 내의 오퍼랜드 부분의 주소가 실제 데이터의 주소를 가지고 있는 포인터의 주소를 나타내는 방식으로, 데이터 처리에 대한 유연성이 좋으나 주소 참조 횟수가 많다는 단점이 있는 주소 지정 방식은?",
                infoChoice : {
                    1: "즉시 주소 지정",
                    2: "간접 주소 지정",
                    3: "직접 주소 지정",
                    4: "계산에 의한 주소 지정",
                },
                infoAnswer : "2",
                infoDesc : "간접 주소 지정(Indirect Addresing)은 명령의 주소 부분으로 지정한 기억 장소의 내용이 실제 데이터가 있는 곳의 주소로 사용되며, 메모리 참조 횟수는 2회 이상입니다., 직접 주소 지정(Direct Addresing)은 주소 부분에 있는 값이 실제 데이터가 있는 주기억 장치 내의 주소를 나타내며 메모리 참조 횟수는 1회입니다., 즉지 주소 지정(Immediate Addresing)은 명령어 주소 부분에 있는 값이 실제 데이터인 구조입니다. 계산에 의한 주소 지정은 데이터가 기억될 위치를 명령의 주소 부분에 있는 값과 특정 레지스터에 기억된 값을 더해서 주소를 지정합니다.",
            },
            {
                infoDate : "2021년 1회",
                infoType : "정보처리기능사",
                infoQuestion : "다음은 명령어 인출 절차를 보인 것이다. 순서가 바르게 나열된 것은?<br> (1) 명령 계수기를 증가시킨다.<br> (2) 명령어를 주기억 장치에서 인출한다.<br> (3) 명령 코드를 명령 레지스터에 옮긴다. (4) 명령 계수기의 값을 번지 레지스터에 옮긴다.",
                infoChoice : {
                    1: "(1) -> (2) -> (3) -> (4)",
                    2: "(1) -> (3) -> (4) -> (2)",
                    3: "(4) -> (2) -> (1) -> (3)",
                    4: "(3) -> (2) -> (1) -> (4)",
                },
                infoAnswer : "3",
                infoDesc : "인출 사이클(Fetch Cycle)은 하나의 명령어 수행을 위해 기억 장치로부터 하나의 명령을 CPU 내의 명령 레지스터로 가지고 오는 사이클입니다. 명령어 인출 순서: (1) 명령 계수기의 값 -> 번지 레지스터<br>(2) 주기억 장치에서 명령어 인출<br>(3) 명령 계수기 증가<br>(4) 명령 코드 -> 명령 레지스터",
            },
            {
                infoDate : "2021년 1회",
                infoType : "정보처리기능사",
                infoQuestion : "원격지에 설치된 입출력 장치를 무엇이라 하는가?",
                infoChoice : {
                    1: "변복조 장치(MODEM)",
                    2: "콘솔(Console)",
                    3: "단말 장치",
                    4: "X-Y 플로터",
                },
                infoAnswer : "3",
                infoDesc : "단말 장치: 원력지에 설치되어 입력과 출력을 담당하는 입출력 장치<br>콘솔: 대형 컴퓨터에서 컴퓨터와 오퍼레이터가 의사 전달을 할 수 있는 장치<br>변복조 장치: 디지털 신호를 아날로그 신호로 변호나는 기능과 반대로 아날로그 신호를 디지털 신호로 복조해 주는 기능을 하는 장치<br>X-Y 플로터: 데이터의 처리 결과를 그래프나 도형으로 인쇄 용지에 출력하는 장치",
            },
            {
                infoDate : "2020년 3회",
                infoType : "정보처리기능사",
                infoQuestion : "입력 장치로만 나열된 것은?",
                infoChoice : {
                    1: "키보드, OCR, OMR, 라인프린터",
                    2: "키보드, OCR, OMR, 플로터",
                    3: "키보드, 라인프린터, OMR, 플로터",
                    4: "키보드, OCR, OMR, MICR",
                },
                infoAnswer : "4",
                infoDesc : "입력 장치: 키보드, OCR, OMR, MICR, 마우스 등",
            },
            {
                infoDate : "2020년 2회",
                infoType : "정보처리기능사",
                infoQuestion : "동시에 여러 개의 입출력 장치를 제어할 수 있는 채널은?",
                infoChoice : {
                    1: "Duplex Channel",
                    2: "Multiplexer Channel",
                    3: "Register Channel",
                    4: "Seletor Channel",
                },
                infoAnswer : "2",
                infoDesc : "멀티플렉서 채널(Multiplexer Channel): 여러 개의 서브 채널이 있어서 저속의 여러 입출력 장치(프린터, 카드)를 도시에 조작할 수 있는 채널<br>바이트 단위로 전송되므로 Byte Multiplexer Channel이라고도 함",
            },
            {
                infoDate : "2017년 상시",
                infoType : "정보처리기능사",
                infoQuestion : "CPU를 경유하지 않고 고속의 입출력 장치와 기억 장치가 직접 데이터를 주고받는 형식은?",
                infoChoice : {
                    1: "DMA(Direct Memory Access)",
                    2: "프로그램에 의한 입출력(Programmed I/O)",
                    3: "인터럽트에 의한 입출력(Interrupt Driven I/O)",
                    4: "채널 제어기에 의한 입출력",
                },
                infoAnswer : "1",
                infoDesc : "DMA: CPU의 간섭 없이 주기억 장치와 입출력 장치 사이에서 직접 전송이 이루어지는 방법으로 DMA 방식에 의한 입출력은 CPU의 레지스터를 경유자히 않고 전송. 고속으로 대량의 데이터를 전송함",
            },
            {
                infoDate : "2020년 1회",
                infoType : "정보처리기능사",
                infoQuestion : "입출력 장치와 주기억 장치 사이에 위치하여 데이터 처리 속도의 차이를 줄이는데 도움이 되는 장치는?",
                infoChoice : {
                    1: "입출력 채널",
                    2: "명령 해독기",
                    3: "연산 장치",
                    4: "인덱스 레지스터",
                },
                infoAnswer : "1",
                infoDesc : "입출력 채널(I/O Channel): CPU의 처리 효율을 높이고 데이터의 입출력을 빠르게 할 수 있게 만든 입출력 전용 처리기로, 입출력 장치와 주기억 장치 사이의 속도 차이를 해결하기 위한 장치(자체 메모리 없음)<br>명령 해독기(Instruction Decoder): IR에 기억된 명령들을 해독해서 각 장치에 제어 신호를 보냄<br>연산 창지(Arithmetic & Logic Unit): 프로그램의 사칙 연산(+, -, *, /), 비교 및 판단, 데이터의 이동, 편집 등의 논리 연산을 수행하고 가산기, 누산기, 감산기, 보수기 등이 있음<br>인덱스 레지스터(Index Register): 인덱스 주소 지정시 사용되는 레지스터",
            },
            {
                infoDate : "2019년 상시",
                infoType : "정보처리기능사",
                infoQuestion : "인터럽트 발생 시 인터럽트를 처리하고 원래 수행하고 있었던 프로그램으로 되돌아가는데 사용되는 레지스터는?",
                infoChoice : {
                    1: "Stack",
                    2: "PC",
                    3: "MBR",
                    4: "PSW",
                },
                infoAnswer : "1",
                infoDesc : "Stack: 삽입과 삭제가 한쪽 끝으로만 수행되며 가장 마지막에 입력된 자료가 가장 먼저 제거되는 구조<br>LIFO(Last In First Out) 구조, 0주소 지정 방식, 인터럽트 처리, 부프로그램 분기, 컴파일러 등에 사용<br>프로그램 카운터(PC; Program Counter): 다음에 수행할 명령어의 번지를 기억<br>기억 레지스터(MBR): 주기억 장치에서 연산에 필요한 자료를 호출하여 저장<br>PSW(Program Status Word): CPU의 작동을 제어하기 위한 기본적인 제어 정보",
            },
            {
                infoDate : "2016년 상시",
                infoType : "정보처리기능사",
                infoQuestion : "컴퓨터 시스템에서 예기치 못한 일이 일어났을 때, 그것을 제어 프로그램에 알려 CPU가 하던 일을 멈추고 다른 작업을 처리하도록 하는 방법을 무엇이라 하는가?",
                infoChoice : {
                    1: "로테이트(rotate)",
                    2: "인터럽트(interrupt)",
                    3: "교착 상태(deadlock)",
                    4: "모듈(module)",
                },
                infoAnswer : "2",
                infoDesc : "인터럽트: 작업 수행중 예기치 못한 돌발적인 사태가 발생했을 때 잠시 작업 수행을 멈추고 상황에 맞는 처리를 한 후, 다시 프로그램을 실행해 나가는 것",
            },
            {
                infoDate : "2020년 3회",
                infoType : "정보처리기능사",
                infoQuestion : "인터럽트(Interrupt)의 종류에 해당되지 않는 것은?",
                infoChoice : {
                    1: "Supervisor Call Interrupt",
                    2: "I/O Interrupt",
                    3: "External Interrupt",
                    4: "Function Interrupt",
                },
                infoAnswer : "4",
                infoDesc : "인터럽트의 종류: 정전, 기계 고장, 외부, 입출력, 프로그램, SVC 인터럽트 등",
            },
            {
                infoDate : "2017년 상시",
                infoType : "정보처리기능사",
                infoQuestion : "기억된 내용을 읽을 수만 있고, 전원이 차단되어도 기억된 내용이 소멸되지 않는 것은?",
                infoChoice : {
                    1: "RAM",
                    2: "ROM",
                    3: "DAM",
                    4: "DOM",
                },
                infoAnswer : "2",
                infoDesc : "ROM(Read Only Memory): 기억된 내용을 읽기만 가능한 장치, 전원의 공급이 끊어져도 그 내용을 기억하는 비휘발성 기억 장치, 롬 바이오스(ROM BIOS)등을 내장<br>RAM:(Random Access Memory): 읽기/쓰기가 가능한 기억 장치, 전원의 공급이 끊어지면 그 내용을 잃어버리는 휘발성 메모리",
            },
            {
                infoDate : "2020년 2회/3회",
                infoType : "정보처리기능사",
                infoQuestion : "캐시 메모리(Cache Memory)의 설명으로 옳은 것은?",
                infoChoice : {
                    1: "대용량 기억 장치용으로 주로 사용된다.",
                    2: "전원이 꺼져도 내용은 그대로 유지된다.",
                    3: "컴퓨터의 주기억 장치로 주로 이용된다.",
                    4: "CPU와 주기억 장치 사이의 속도 차이를 해결하기 위한 고속 메모리로 이용된다.",
                },
                infoAnswer : "4",
                infoDesc : "캐시 메모리: CPU와 주기억 장치 사이에 있는 고속의 버퍼 메모리로 자주 참조되는 데이터나 프로그램을 메모리에 저장, 메모리 접근 시간을 감소시키기 위한 목적으로 사용됨",
            },
            {
                infoDate : "2021년 1회",
                infoType : "정보처리기능사",
                infoQuestion : "주기억 장치의 용량을 실제보다 크게 활용할 수 있도록 하기 위하여 실제 자료를 보조 기억 장치에 두고 주기억 장치에 있는 것과 같이 처리시킬 수 있는 기억 장치는?",
                infoChoice : {
                    1: "가상 기억 장치",
                    2: "확장 기억 장치",
                    3: "캐시 기억 장치",
                    4: "기본 기억 장치",
                },
                infoAnswer : "1",
                infoDesc : "가상 기억 장치(Virtual Memory): 주기억 장치의 용량이 부족하여 보조 기억 장치의 일부를 마치 주기억 장치인 것처럼 이용하는 메모리 관리 기법",
            },
            {
                infoDate : "2020년 3회",
                infoType : "정보처리기능사",
                infoQuestion : "컴퓨터 시스템의 중앙 처리 장치를 구성하는 하나의 회로로서, 컴퓨터 안에서 산술 연산 및 논리 연산을 수행하는 장치는?",
                infoChoice : {
                    1: "Arithmetic Logic Unit",
                    2: "Memory Unit",
                    3: "Associative Memory Unit",
                    4: "Punch Card System",
                },
                infoAnswer : "1",
                infoDesc : "Arithmetic Logic Unit(연산 장치): 프로그램 연산 명령의 수행, 비교, 판단 및 데이터의 이동, 편집 등의 기능을 수행",
            },
            {
                infoDate : "2020년 4회",
                infoType : "정보처리기능사",
                infoQuestion : "입출력 장치의 동작 속도와 전자계산기 내부의 동작 속도를 맞추는 데 사용되는 레지스터는?",
                infoChoice : {
                    1: "시프트 레지스터(Shift Register)",
                    2: "시퀀스 레지스터(Sequence Register)",
                    3: "어드레스 레지스터(Address Register)",
                    4: "버퍼 레지스터(Buffer Register)",
                },
                infoAnswer : "4",
                infoDesc : "버퍼 레지스터: 각 장치 간의 속도 차를 해결하기 위해 데이터를 일시적으로 기억하는 레지스터",
            },
            {
                infoDate : "2018년 상시",
                infoType : "정보처리기능사",
                infoQuestion : "중앙 처리 장치(CPU)에 해당하는 부분을 하나의 대규모 집적 회로의 칩에 내장시켜 기능을 수행하게 하는 것은?",
                infoChoice : {
                    1: "컴파일러",
                    2: "마이크로프로세서",
                    3: "소프트웨어",
                    4: "레지스터",
                },
                infoAnswer : "2",
                infoDesc : "마이크로프로세서(Microprocessor): CPU(중앙 처리 장치)의 기능을 수행하기 위하여 만든 고밀도 집적 회로(LS)로 연산 장치, 제어 장치, 레지스터로 구성",
            },
            {
                infoDate : "2019년 상시",
                infoType : "정보처리기능사",
                infoQuestion : "데이터베이스 디자인 단계의 순서가 옳은 것은?<br>ㄱ. 데이터베이스의 목적을 정의<br>ㄴ. 데이터베이스에서 필요한 테이블을 정의<br>ㄷ. 테이블에서 필요한 필드를 정의<br>ㄹ. 테이블 간의 관계를 정의",
                infoChoice : {
                    1: "ㄱ-ㄹ-ㄴ-ㄷ",
                    2: "ㄱ-ㄷ-ㄴ-ㄹ",
                    3: "ㄱ-ㄴ-ㄹ-ㄷ",
                    4: "ㄱ-ㄴ-ㄷ-ㄹ",
                },
                infoAnswer : "4",
                infoDesc : "데이터베이스 디자인 단계<br>데이터베이스의 목적을 정의 -> 데이터베이스에서 필요한 테이블을 정의 -> 테이블에서 필요한 필드를 정의 -> 테이블 간의 관계를 정의",
            },
            {
                infoDate : "2020년 4회",
                infoType : "정보처리기능사",
                infoQuestion : "데이터베이스 설계 단계를 순서대로 기술한 것은?",
                infoChoice : {
                    1: "개념적 설계 -> 물리적 설계 -> 논리적 설계",
                    2: "개념적 설계 -> 논리적 설계 ->물리적 설계",
                    3: "논리적 설계 - > 개념적 설계 -> 물리적 설계",
                    4: "논리적 설계 -> 물리적 설계 -> 개념적 설계",
                },
                infoAnswer : "2",
                infoDesc : "데이터베이스 설계 단계<br>요구 분석 단계 -> 개념적 설계 -> 논리적 설게 -> 물리적 설계 -> 구현",
            },
            {
                infoDate : "2020년 2회",
                infoType : "정보처리기능사",
                infoQuestion : "레지스터에 새로운 데이터를 전송하면 먼저 있던 내용은 어떻게 되는가?",
                infoChoice : {
                    1: "먼저 내용은 다른 곳으로 전송되고 새로운 내용만 기억된다.",
                    2: "기억된 내용에 아무런 변화가 없다.",
                    3: "먼저 내용은 지워지고 새로운 내용만 기억된다.",
                    4: "누산기(Accurnulator)에서는 덧셈이 이루어진다.",
                },
                infoAnswer : "3",
                infoDesc : "레지스터(Register): 연산의 결과나 처리할 명령을 기억하는 고속의 임시 기억 장치로, 새로운 데이터가 전송되면 이전 내용은 지워지고 새로 전송된 내용만 기억함",
            },
            {
                infoDate : "2020년 2회",
                infoType : "정보처리기능사",
                infoQuestion : "다음 중 RISC(Reduced Instruction Set Computer)의 설명으로 옳은 것은?",
                infoChoice : {
                    1: "메모리에 대한 액세스는 LOAD와 STORE만으 로 한정되어 있다.",
                    2: "명령어마다 다른 수행 사이클을 가지므로 파이 프라이닝이 효율적이다.",
                    3: "마이크로 코드에 의해 해석 후 명령어를 수행한다.",
                    4: "주소 지정 방식이 다양하게 존재한다.",
                },
                infoAnswer : "1",
                infoDesc : "RISC(Reduced Instruction Set Computer):<br>명령어 축약형 CPU, 주소 지정 모드와 명령어의 종류가 적음, LOAD와 STORE로 메모리 접근<br>프로그래밍이 어려우나 처리 속도가 빠름, 고성능의 워크스테이션이나 그래픽용 컴퓨터에서 사용",
            },
            {
                infoDate : "2020년 3회",
                infoType : "정보처리기능사",
                infoQuestion : "데이터베이스 개체(Entity)의 속성 중 하나의 속성이 가질 수 있는 모든 값의 집합을 무엇이라고 하는가?",
                infoChoice : {
                    1: "객체(Object)",
                    2: "속성(Attribute)",
                    3: "도메인(Domain)",
                    4: "카디널리티(Cardinality)",
                },
                infoAnswer : "3",
                infoDesc : "도메인: 하나의 속성이 취할 수 있는 모든 값의 집합",
            },
            {
                infoDate : "2018년 상시",
                infoType : "정보처리기능사",
                infoQuestion : "데이터베이스 시스템의 구성 요소로 가장 적절한 것은?",
                infoChoice : {
                    1: "개념 스키마, 핵심 스키마, 구체적 스키마",
                    2: "외부 스키마, 핵심 스키마. 내부 스키마",
                    3: "개념 스키마, 구체적 스키마, 응용 스키마",
                    4: "외부 스키마, 개념 스키마, 내부 스키마",
                },
                infoAnswer : "4",
                infoDesc : "데이터베이스 시스템의 구성 요소: 외부 스키마, 개념 스키마, 내부 스키마",
            },
            {
                infoDate : "2021년 1회",
                infoType : "정보처리기능사",
                infoQuestion : "데이터베이스 시스템의 전체적인 관리 및 운영을 책임지는 사람을 의미하는 것은?",
                infoChoice : {
                    1: "DEGREE",
                    2: "SCHEMA",
                    3: "DBA",
                    4: "DBM",
                },
                infoAnswer : "3",
                infoDesc : "DBA(Data Base Administrator): 시스템의 보안성과 무결성 책임. 시스템성능 감지와 사용자의 요구 및 불편 해소 등 시스템에 대한 전반적인 책임을 지는 데이터베이스 관리자<br>DEGREE: 한 릴레이션(테이블)에서 속성(필드=열)의 개수로 차수라고도 함<br>스키마Schema): 데이터베이스를 구성하는 파일, 레코드, 항목의 형식과 상호 관계 전체를 정의한 것으로 외부 스키마, 개념 스키마, 내부 스키마가 있음<br>DBM: Data Base Machine으로, 데이터 베이스를 사용하는 기계(컴퓨터)",
            },
            {
                infoDate : "2020년 2회",
                infoType : "정보처리기능사",
                infoQuestion : "관계 데이터베이스에서 속성(Atribute)의 수를 의미하는 것은?",
                infoChoice : {
                    1: "카디널리티(Cardinality)",
                    2: "도메인(Domain)",
                    3: "차수 Degree)",
                    4: "릴레이션(Relation)",
                },
                infoAnswer : "3",
                infoDesc : "차수(Degree): 한 릴레이션(테이블)에서 속성(필드-열)의 개수 예) 4개(성명. 주소, 학교명, 성벌)<br>카디널리티(Cardinality): 기수라고도 하며 한 릴레이션(테이블)에서의 튜플의 개수를 의미함<br>릴레이션(Relation): 관계형 데이터베이스에서 2차원 형태의 가로, 세로 즉 행과 열의 형태로 나타내는 저장소를 의미하며 테이블(Table)이라고도 함",
            },
            {
                infoDate : "2019년 상시",
                infoType : "정보처리기능사",
                infoQuestion : "하나 이상의 기본 테이블로부터 유도되어 만들어지는 가상 테이블은?",
                infoChoice : {
                    1: "뷰(VIEW)",
                    2: "유리창(WINDOW)",
                    3: "테이블(TABLE)",
                    4: "도메인(DOMAIN)",
                },
                infoAnswer : "1",
                infoDesc : "뷰(VIEW) : 외부스키마는 서브 스키마 또는 뷰라고도 하며 뷰는 하나 이상의 가상 테이블에서 유도하여 만든 가상 테이블을 의미함",
            },
            {
                infoDate : "2020년 2회",
                infoType : "정보처리기능사",
                infoQuestion : "SQL의 기본 검색문 형식으로 괄호 (ㄱ) ~ (ㄹ)의 내용이 옳게 짝지어진 것은?<br>SELECT(ㄱ)<br>FROM(ㄴ)<br>WHERE(ㄷ)<br>GROUP BY (ㄹ)",
                infoChoice : {
                    1: "(ㄱ) 열 이름 (ㄴ) 속성 (ㄷ) 테이블 (ㄹ) 조건",
                    2: "(ㄱ) 열 이름 (ㄴ) 속성 (ㄷ) 조건 (ㄹ) 테이블",
                    3: "(ㄱ) 열 이름 (ㄴ) 테이블 (ㄷ) 조건 (ㄹ) 그룹",
                    4: "(ㄱ) 릴레이션 (ㄴ)열 이름 (ㄷ) 조건 (ㄹ) 그룹",
                },
                infoAnswer : "3",
                infoDesc : "SELECT(열 이름)<br>FROM(테이블)<br>WHERE(조건)<br>GROUP BY(그룹)",
            },
            {
                infoDate : "2018년 상시",
                infoType : "정보처리기능사",
                infoQuestion : "데이터 정의어(DDL)에 해당하는 SQL 명령은?",
                infoChoice : {
                    1: "UPDATE",
                    2: "CREATE",
                    3: "INSERT",
                    4: "SELECT",
                },
                infoAnswer : "2",
                infoDesc : "데이터 정의 언어(DDL): 데이터를 입력하기 위한 테이블의 정의나 정보를 참조 하기 위한 뷰를 정의하기 위한 언어<br>CREATE: 데이터베이스 테이블, 뷰 등의 작성<br>ALTER: 데이터베이스, 테이블의 구조 변경<br>DROP : 데이터베이스, 테이블, 뷰 등의 삭제",
            },
            {
                infoDate : "2021년 1회",
                infoType : "정보처리기능사",
                infoQuestion : "SQL문의 형식 중 옳지 않은 것은?",
                infoChoice : {
                    1: "INSERT - SET - WHERE",
                    2: "UPDATE - SET - WHERE",
                    3: "DELETE - FROM - WHERE",
                    4: "SELECT - FROM - WHERE",
                },
                infoAnswer : "1",
                infoDesc : "INSERT(삽입문): 테이블에 새로운 데이터(행)을 삽입하며, INSERT-INTO-VALUES의 유형을 가짐",
            },
            {
                infoDate : "2021년 1회",
                infoType : "정보처리기능사",
                infoQuestion : "운영체제의 특성으로 거리가 먼 것은?",
                infoChoice : {
                    1: "효율성",
                    2: "신뢰성",
                    3: "복잡성",
                    4: "용이성",
                },
                infoAnswer : "3",
                infoDesc : "운영체제의 특성 : 효율성, 신뢰성, 용이성 등",
            },
            {
                infoDate : "2021년 2회",
                infoType : "정보처리기능사",
                infoQuestion : "다음 SQL 명령문의 의미로 가장 적절한 것은?<br>DROP TABLE 학과 CASCADE;",
                infoChoice : {
                    1: "학과 테이블을 제거하시오",
                    2: "학과 필드를 제거하시오",
                    3: "학과 테이블과 이 테이블을 참조하는 다른 테이블도 함께 제거하시오",
                    4: "학과 테이블이 다른 테이블에 참조 중이면 제거하지 마시오",
                },
                infoAnswer : "3",
                infoDesc : "CASCADE : 제거 대상의 제거와 함께 이를 참조하는 다른 데이터 객체에 대해서도 제거 작업이 실시됨",
            },
            {
                infoDate : "2020년 3회",
                infoType : "정보처리기능사",
                infoQuestion : " SQL에서 데이터베이스에 대한 일련의 처리를 하나로 모은 작업 단위로 관리할 수 있는데, 이 작업 단위는?",
                infoChoice : {
                    1: "페이지(Page)",
                    2: "세그먼테이션(Segmentation)",
                    3: "디스패치(Dispatch)",
                    4: "트랜잭션(Transaction)",
                },
                infoAnswer : "4",
                infoDesc : "트랜잭션(Transaction): SOL에서 DataBase에 대한 일련의 처리를 하나로 모은 작업 단위<br>페이지(Page) : 주기억 장지에서 사용되는 크기가 일정한 데이터 단위<br>세그먼테이션(Segmnentation) : 세그먼트 기법으로써 가상 기억 장치 관리 기법에 속함<br>디스패치(Dispaich) : 대기 중인 프로세스들 중 CPU의 사용권한을 부여하는 것",
            },
            {
                infoDate : "2019년 상시",
                infoType : "정보처리기능사",
                infoQuestion : "컴퓨터 시스템의 성능을 최적화하기 위하여 사용되는 운영체제의 기능과 거리가 먼 것은?",
                infoChoice : {
                    1: "기능 초기 설정 기능",
                    2: "인터페이스 기능",
                    3: "이식성",
                    4: "시스템 비보호 기능",
                },
                infoAnswer : "4",
                infoDesc : "운영체제의 기능 : 사용자와 컴퓨터의 인터페이스 제공, 자원 관리 기능, 자원의 공유, 시스템의 오류 처리, 초기 설정, 이식성 기능 등",
            },
            {
                infoDate : "2018년 상시",
                infoType : "정보처리기능사",
                infoQuestion : "운영체제를 제어 프로그램(Control Program)과 처리 프로그램(Processing Program)으로 분류했을 때, 제어 프로그램에 해당하지 않는 것은?",
                infoChoice : {
                    1: "감시 프로그램(Supervisor Program)",
                    2: "데이터 프로그램(Data Management Program)",
                    3: "문제 프로그램(Problem Program)",
                    4: "작업 제어 프로그램(Job Control Program)",
                },
                infoAnswer : "3",
                infoDesc : "처리 프로그램: 언어 번역, 서비스, 문제 처리 프로그램<br>제어 프로그램: 감시 프로그램, 작업 관리 프로그램, 데이터 관리 프로그램",
            },
            {
                infoDate : "2020년 2회",
                infoType : "정보처리기능사",
                infoQuestion : "스프레드시트 작업에서 반복되거나 복잡한 단계를 수행하는 작업을 일괄적으로 자동화시켜 처리하는 방법에 해당하는 것은?",
                infoChoice : {
                    1: "매크로",
                    2: "정렬",
                    3: "검색",
                    4: "필터",
                },
                infoAnswer : "1",
                infoDesc : "매크로(Macro): 자주 사용하는 명령, 반복적인 작업 등을 매크로로 기록하여 해당 작업이 필요할 때마다 바로 가기 키나 실행 단추를 눌러 쉽고 빠르게 작업을 수행하는 기능<br>정렬(Sort): 데이터를 특정 필드의 크기 순서에 따라 재배열하는 기능<br>필터(Filler): 사용자가 설정하는 특정 조건을 만족하는 자료만 검색, 추출하는 기능",
            },
            {
                infoDate : "2021년 1회",
                infoType : "정보처리기능사",
                infoQuestion : "컴퓨터 시스템의 성능 평가 기준으로 거리가 먼 것은?",
                infoChoice : {
                    1: "처리 능력(Throughput)",
                    2: "응답 시간(Turnaround Time)",
                    3: "비용(Cost)",
                    4: "신뢰도(Reliability)",
                },
                infoAnswer : "3",
                infoDesc : "비용은 컴퓨터 시스템의 성능 평가 기준 요소에 포함되지 않음<br>컴퓨터의 성능 평가 기준 : 처리 능력(Throughput), 응답 시간(Turnaround Time), 신뢰도(Reliability), 사용 가능도(Availability)",
            },
            {
                infoDate : "2019년 상시",
                infoType : "정보처리기능사",
                infoQuestion : "운영체제(OS)에 대한 설명으로 틀린 것은?",
                infoChoice : {
                    1: "OS는 컴퓨터와 사용자 간의 중간자 역할을 한다.",
                    2: "OS는 H/W 및 주변 장치를 관리하는 역할을 한다.",
                    3: "하나의 컴퓨터 내의 모든 소프트웨어는 각각 자신의 OS를 따로 가지고 있어야 한다.",
                    4: "일반적으로 OS는 사용자가 컴퓨터를 제어하기 쉽게할 수있는 인터페이스를 제공한다.",
                },
                infoAnswer : "3",
                infoDesc : "하나의 컴퓨터 내의 모든 소프트웨어는 각각 자신의 OS를 따로 가지고 있을 필요가 없음",
            },
            {
                infoDate : "2019년 상시",
                infoType : "정보처리기능사",
                infoQuestion : "운영체제의 스케줄링 기법 중 선점(Preemptive) 스케줄링에 해당하는 것은?",
                infoChoice : {
                    1: "SRT",
                    2: "SJF",
                    3: "FIFO",
                    4: "HRN",
                },
                infoAnswer : "1",
                infoDesc : "선점형(Preemplive) 기법 : 하나의 프로세스가 CPU를 점유하고 있을 때 다른 프로세스가 CPU을 빼앗아 차지할 수 있는 방법, 대화식 시분할 시스템, 실시간 시스템에서 사용됨, 종류: RR, SRT, MFQ(다단계 피드백 큐)<br>비선점형(Non-Preemptive) 기법 : 특정한 프로세스의 작업이 끝날 때까지 CPU를 독점하는 방법, 종류: FIFO, 우선순위(Priority), SJF, HRN",
            },
            {
                infoDate : "2020년 2회",
                infoType : "정보처리기능사",
                infoQuestion : "MS-DOS 부팅 시 필요한 파일의 읽는 순서를 옳게 나열한 것은?<br>(1) MSDOS.SYS<br>(2) IO.SYS<br>(3) CONFIG.SYS<br>(4) AUTOEXET.BAT<br>(5) COMMAND.COM",
                infoChoice : {
                    1: "(1) - (2) - (3) - (4) - (5)",
                    2: "(2) - (1) - (3) - (5) - (4)",
                    3: "(2) - (1) - (3) - (4) - (5)",
                    4: "(1) - (2) - (5) - (3) - (4)",
                },
                infoAnswer : "2",
                infoDesc : "부팅(Booting) 순서<br>IO.SYS -> MSDOS.SYS -> CONFIG.SYS -> COMMAND.COM -> AUTO-EXEC.BAT",
            },
            {
                infoDate : "2020년 4회",
                infoType : "정보처리기능사",
                infoQuestion : "도스(MS-DOS)에서 'ATTRIB' 명령 사용 시, 읽기 전용 속성을 해제할 때 사용하는 옵션은?",
                infoChoice : {
                    1: "+H",
                    2: "-S",
                    3: "-A",
                    4: "-R",
                },
                infoAnswer : "4",
                infoDesc : " ATTRIB: 파일의 속성을 지정 및 해제하는 명령어<br>사용법: ATTRIB [+(속성 설정)속성 / -(속성 해제)속성][드라이브:][경로]파일명 [/옵션]<br>속성과 기능 설명<br>R(Read Only): 읽기 전용 속성<br>A(Archive): 저장 기능 속성<br>S(System): 시스템 파일 속성<br>H(Hidden): 숨김 속성",
            },
            {
                infoDate : "2020년 4회",
                infoType : "정보처리기능사",
                infoQuestion : "UNIX의 특징을 설명한 것으로 틀린 것은?",
                infoChoice : {
                    1: "대부분 고급 언어인 C 언어로 구성되어 타 기종에 이식성이 높다.",
                    2: "동시에 여러 작업(task)을 수행할 수 있는 시스템이다.",
                    3: "파일 구조가 선형구조의 형태로 되어 있어 파일을 효과적으로 운영할 수 있다.",
                    4: "다수의 사용자(user)가 동시에 사용할 수 있는 시스템이다.",
                },
                infoAnswer : "3",
                infoDesc : "파일, 디렉터리 및 서브 디렉터리의 계층적인 구조로 트리 구조를 가짐",
            },
            {
                infoDate : "2018년 상시",
                infoType : "정보처리기능사",
                infoQuestion : "다음 중 온라인 실시간 시스템의 조회 방식에 가장 적합한 업무는?",
                infoChoice : {
                    1: "객관식 채점 업무",
                    2: "좌석 예약 업무",
                    3: "성적 처리 업무",
                    4: "봉급 계산 업무",
                },
                infoAnswer : "2",
                infoDesc : "실시간 처리 시스템(Real Time Processing System) : 데이터가 발생되는 즉시 처리하는 방식으로 바로 응답을 받아볼 수 있는 시스템이며 항상 온라인을 유지해야 함, 항공 및 철도 승차권 예약, 좌석 예약, 은행 온라인 업무, 로봇 제어 등",
            },
            {
                infoDate : "2017년 상시",
                infoType : "정보처리기능사",
                infoQuestion : "다중 프로그래밍 환경에서 하나 또는 그 이상의 프로세스가 실행이 불가능한 특정 사건(Event)을 무한정 기다리는 상태를 무엇이라 하는가?",
                infoChoice : {
                    1: "Swapping",
                    2: "Pipelining",
                    3: "Overlay",
                    4: "Deadlok",
                },
                infoAnswer : "4",
                infoDesc : "교착 상태(Deadliock): 자원은 한정되어 있으나 각 프로세스 들이 서로 자원을 차지하려고 무한정 대기하는 상태로, 해당 프로세스의 진행이 중단되는 상태를 의미<br>파이프라아닝(Pipelining) : 하나의 명령을 여러 개의 독립된 실행 단계로 나우고 이들을 순서에 따라 차례로 실행해 나가는 방법으로, CPU의 실행 속도가 빨라짐",
            },
            {
                infoDate : "2019년 상시",
                infoType : "정보처리기능사",
                infoQuestion : "페이지 대체 알고리즘에서 계수기를 두어 가장 오랫동안 참조되지 않은 페이지를 교체할 페이지로 선택하는 방법은?",
                infoChoice : {
                    1: "FIFO",
                    2: "LRU",
                    3: "LFU",
                    4: "OPT",
                },
                infoAnswer : "2",
                infoDesc : "LRU(Least Recently Used): 가장 오랫동안 사용되지 않은 페이지를 교체할 페이지로 선택하는 기법<br>FIFO(First in First Out): 주기억 장치 내에 가장 먼저 들어온 가장 오래된 페이지를 교체할 페이지로 선택하는 기법<br>LFU(Least Frequently Used): 사용된 횟수가 가장 적은 페이지를 교체할 페이지로 선택하는 기법<br>최적화 기법(OPT; OPTimal replacement): 앞으로 가장 오랫동안 사용되지 않거나 사용도가 낮을 페이지를 선택하여 교체하는 기법",
            },
            {
                infoDate : "2021년 1회",
                infoType : "정보처리기능사",
                infoQuestion : "실행 중인 프로그램이나 시스템을 중지시킬 수 있는 수행 중단 기능(Break = on)을 설정할 수 있는 도스 파일은?",
                infoChoice : {
                    1: "IO.SYS",
                    2: "COMMAND.COM",
                    3: "CONFIG. SYS",
                    4: "AUTOEXEC.BAT",
                },
                infoAnswer : "3",
                infoDesc : "환경 설정 파일로 부팅 시 컴퓨터 시스템 및 주변 장치에 필요한 기본 환경을 설정하고 프로그램의 실행을 중단하는 기능의 설정 및 해제를 담당",
            },
            {
                infoDate : "2019년 상시",
                infoType : "정보처리기능사",
                infoQuestion : "도스(MS-DOS)에서 단편화되어 있는 파일의 저장 상태를 최적화하여 디스크의 작동 효율을 높이는 명령은?",
                infoChoice : {
                    1: "DISKCOMP",
                    2: "CHKDSK",
                    3: "DEFRAG",
                    4: "DISKCOPY",
                },
                infoAnswer : "3",
                infoDesc : "DEFRAG: 디스크에 생긴 단편화 현상을 제거하는 명령",
            },
            {
                infoDate : "2020년 2회",
                infoType : "정보처리기능사",
                infoQuestion : "도스(MS- DOS)에서 사용자가 잘못해 파일의 정보를 삭제하였을 때, 이를 복원하는 명령어는?",
                infoChoice : {
                    1: "DELETE",
                    2: "UNDELETE",
                    3: "FDISK",
                    4: "ANTI",
                },
                infoAnswer : "2",
                infoDesc : "UNDELETE: 삭제했던 파일을 복구<br>DEL: 파일 삭제<br>FDSK: 하드 디스크의 논리적인 파티션 설정",
            },
            {
                infoDate : "2019년 상시",
                infoType : "정보처리기능사",
                infoQuestion : "원도우즈에서 작업 표시줄(Task Bar)의 속성에 대한 설명으로 틀린 것은?",
                infoChoice : {
                    1: "작업 표시줄 자동 숨기기를 설정하면 화면에 필요시만 나타난다.",
                    2: "현재 실행 중인 프로그램은 작업 표시줄에 표시된다.",
                    3: "작업 표시줄 여백에 마우스 포인터를 위치시키고 마우스의 왼쪽 버튼을 눌러 속성을 볼 수 있다.",
                    4: "작업 표시줄 잠금은 작업 표시줄의 영역을 임의로 설정하지 못한다.",
                },
                infoAnswer : "3",
                infoDesc : "작업 표시줄 여백에 마우스 포인터를 위치시키고 마우스의 오른쪽 버튼을 놀러 속성을 볼 수 있음",
            },
            {
                infoDate : "2019년 상시",
                infoType : "정보처리기능사",
                infoQuestion : "UNIX에서 파일의 내용을 화면에 보여주는 명령은?",
                infoChoice : {
                    1: "rm",
                    2: "cat",
                    3: "mv",
                    4: "type",
                },
                infoAnswer : "2",
                infoDesc : "cat: 파일의 내용 표시(DOS의 TYPE)<br>rm: 파일 삭제 명령(DOS의 DEL)<br>mv: 파일 및 디렉터리 이동 또는 이름 변경(DOS의 RENAME(= REN))<br>type: 텍스트 파일의 내용을 보여주는 DOS 명령어",
            },
            {
                infoDate : "2020년 2회/4회",
                infoType : "정보처리기능사",
                infoQuestion : "UNIX에서 네트워크 상의 문제를 진단할 수 있는 명령어는?",
                infoChoice : {
                    1: "ping",
                    2: "cd",
                    3: "pwd",
                    4: "who",
                },
                infoAnswer : "1",
                infoDesc : "ping: 네트워크에 연결되어 있는 다른 컴퓨터들의 연결 상태 점검<br>cd: 디렉터리 경로 변경<br> pwd: 현재 작업중인 디렉터리의 경로 표시<br>who: 현재 시스템을 사용하고 있는 사용자의 정보",
            },
            {
                infoDate : "2016년 4회",
                infoType : "정보처리기능사",
                infoQuestion : "다음 중 Linux의 특징에 대한 설명으로 옳지 않은 것은?",
                infoChoice : {
                    1: "멀티태스킹을 지원한다.",
                    2: "UNIX 운영체제와의 호환성이 원활하지 않다.",
                    3: "동시에 여러 사용자가 사용할 수 있는 운영체제이다.",
                    4: "소스 코드가 공개되어 있어 자유롭게 활용이 가능한 오픈 소스 운영체제이다.",
                },
                infoAnswer : "2",
                infoDesc : "UNIX 운영체제와 완전한 호환이 가능함",
            },
            {
                infoDate : "2014년 상시",
                infoType : "정보처리기능사",
                infoQuestion : "데이터 통신 네트워크 유형 중 분산 처리 네트워크의 장점과 거리가 먼 것은?",
                infoChoice : {
                    1: "데이터의 신속한 현장 처리가 가능하다.",
                    2: "시스템의 운영조직이 간단해진다.",
                    3: "장애 발생시 전체적으로 기능이 마비되지 않는다.",
                    4: "자원의 공유가 가능하다.",
                },
                infoAnswer : "2",
                infoDesc : "분산 처리 네트워크 방식은 각 지역별로 자료를 분산 처리하는 방식으로 자원의 공유가 가능하며 시스템의 과부하를 방지, 장애가 발생하더라도 기능 유지가 됨",
            },
            {
                infoDate : "2020년 2회/3회",
                infoType : "정보처리기능사",
                infoQuestion : "UNIX 시스템에서 명령어 해석기에 해당하는 것은?",
                infoChoice : {
                    1: "셸(Shell)",
                    2: "커널(Kernel)",
                    3: "유틸리티(Utility)",
                    4: "응용 프로그램(Application Program)",
                },
                infoAnswer : "1",
                infoDesc : "셸(Shell): 사용자와 UNIX 간의 인터페이스 역할을 하며, DOS의 COMMAND 같은 역할을 담당함<br>커널(Kornel) : UNIX의 가장 핵심적인 부분으로 항상 주기억 장치에 상주하며 시스템의 자원를 관리<br>유틸리티(Utility): DOS의 외부 명령어에 해당, 사용자 편리를 위해 준비된 시스템 프로그램",
            },
            {
                infoDate : "2020년 3회",
                infoType : "정보처리기능사",
                infoQuestion : "UNIX 시스템에서 현재 작업 중인 프로세스의 상태를 알기 위해 사용하는 명령어는?",
                infoChoice : {
                    1: "cat",
                    2: "ps",
                    3: "ls",
                    4: "cp",
                },
                infoAnswer : "2",
                infoDesc : "ps: 프로세스 상태 보기<br>ls: 지정한 디렉터리의 파일을 보여줌<br>cp: 파일 복사 명령",
            },
            {
                infoDate : "2019년 상시",
                infoType : "정보처리기능사",
                infoQuestion : "현재의 작업 디렉터리를 나타내기 위한 UNIX 명령은?",
                infoChoice : {
                    1: "cd",
                    2: "pwd",
                    3: "kill",
                    4: "cp",
                },
                infoAnswer : "2",
                infoDesc : "pwd : 현재 디렉터리의 검로를 표시(print working directory)<br>cd: 디렉터리 경로 변경<br>cp: 파일 복사 명령<br>kill: 강제로 수행중인 프로세스를 중지",
            },
            {
                infoDate : "2020년 2회/4회",
                infoType : "정보처리기능사",
                infoQuestion : "데이터 통신의 정의에 대한 설명 중 옳지 않은 것은?",
                infoChoice : {
                    1: "공중 전화 교환망을 통하여 접속된 전화기를 이용한 음성 통신",
                    2: "2진 부호 형태의 정보를 목적물로 하는 통신",
                    3: "정보 기기 사이에 디지털 형태의 정보를 송수신 하는 통신",
                    4: "전기 통신 회선에 컴퓨터를 접속하여 정보를 송수신 및 처리하는 통신",
                },
                infoAnswer : "1",
                infoDesc : "정보 통신 : 가공 처리된 문자, 음성, 영상 등과 같은 일련의 정보를 기기 간의 유ㆍ무선을 통해 서로 주고받는 행위",
            },
            {
                infoDate : "2020년 2회",
                infoType : "정보처리기능사",
                infoQuestion : "다음 중 통신 제어 장치의 역할과 거리가 먼 것은?",
                infoChoice : {
                    1: "통신 회선과 중앙 처리 장치의 결합",
                    2: "중앙 처리 장치와 데이터의 송수신 제어",
                    3: "데이터의 교환 및 축적 제어",
                    4: "회선 접속 및 전송 에러 제어",
                },
                infoAnswer : "3",
                infoDesc : "통신 제어 장치(Communication Control Unit): 데이터 전송 회선과 컴퓨터 사이를 연결하고 통신 회선과 중앙 처리 장치를 결합하여 데이터의 송ㆍ수신 및 회선 접속, 전송 에러를 제어함",
            },
            {
                infoDate : "2019년 상시",
                infoType : "정보처리기능사",
                infoQuestion : "하나의 중앙 처리 장치에 통신 회선을 통하여 여러 개의 입출력 장치를 항시 연결해서 자료를 처리하는 방식은?",
                infoChoice : {
                    1: "중앙 처리 방식",
                    2: "온라인 시스템",
                    3: "오프라인 시스템",
                    4: "일괄 처리 방식",
                },
                infoAnswer : "2",
                infoDesc : "온라인 시스템: 중앙 처리 장치에 통신 회선을 사용하여 여러 개의 단말 장치를 연결하여 처리하는 방식<br>오프라인 시스템: 통신 제어 장치 없이 일정량 데이터를 모았다가 처리<br>일괄 처리 방식: 일정 기간, 일정량의 데이터를 모았다가 처리",
            },
            {
                infoDate : "2021년 1회",
                infoType : "정보처리기능사",
                infoQuestion : "광섬유 케이블의 장점이 아닌 것은?",
                infoChoice : {
                    1: "잡음 영향이 적다.",
                    2: "대역폭이 넓다.",
                    3: "도청이 어렵다.",
                    4: "누화량이 많다.",
                },
                infoAnswer : "4",
                infoDesc : "광섬유 케이블은 전자 유도의 영향을 받지 않으므로 누화(혼선)을 방지할 수 있음",
            },
            {
                infoDate : "2019년 상시",
                infoType : "정보처리기능사",
                infoQuestion : "일괄 처리(Batch Processing) 방법에 속하지 않는 것은?",
                infoChoice : {
                    1: "자료가 발생할 때마다 보조 기억 장치에 기억해 두었다가 필요시에 처리하는 방식",
                    2: "자료가 일정량 수신되면 처리하는 방식",
                    3: "자료를 일정 기간 단위로 처리하는 방식",
                    4: "자료가 발생하는 즉시 필요한 처리를 하는 방식",
                },
                infoAnswer : "3",
                infoDesc : "자료가 발생하는 즉시 필요한 처리를 하는 방식 -> 실시간 처리(Real Time Processing)",
            },
            {
                infoDate : "2020년 3회",
                infoType : "정보처리기능사",
                infoQuestion : "On-Line System 중에서 항공기나 열차의 좌석 예약, 은행의 예금 업무 등 Data가 발생하였을 때, 그것을 즉시 처리하는 System은?",
                infoChoice : {
                    1: "Frequency Sharing System",
                    2: "Real Time System",
                    3: "Batch Processing System",
                    4: "Duplex System",
                },
                infoAnswer : "2",
                infoDesc : "Real Time System(실시간 처리): 은행의 예금 업무와 같이 데이터가 발생하는 즉시 처리하는 방식<br>Batch Processing System(일필 처리 방식): 자료를 일정량, 일정 기간 동안 모았다가 처리하는 방식으로 주로 오프라인(Off- Line) 방식을 사용<br>Duplex System(전이중 방식): 전화와 같이 양쪽 방항으로 동시에 정보 전송이 가능한 방식",
            },
            {
                infoDate : "2020년 2회/4회",
                infoType : "정보처리기능사",
                infoQuestion : "비동기식 전송에 대한 설명으로 옳지 않은 것은?",
                infoChoice : {
                    1: "스타트 비트와 스톱 비트가 있다.",
                    2: "문자 사이마다 휴지 기간이 있을 수 있다.",
                    3: "동기용 문자가 쓰인다.",
                    4: "동기는 문자 단위로 이루어진다.",
                },
                infoAnswer : "3",
                infoDesc : "동기용 문자(SYN)는 동기식 방식에서 사용하고, 비동기식 전송은 스타트 비트와 스톱 비트를 삽입하여 동기를 맞춤",
            },
            {
                infoDate : "2016년 상시",
                infoType : "정보처리기능사",
                infoQuestion : "아날로그 신호를 디지털 신호로 전송하기 위해 필수적인 처리 과정이 아닌 것은?",
                infoChoice : {
                    1: "표본화",
                    2: "정보화",
                    3: "양자화",
                    4: "선부호화",
                },
                infoAnswer : "2",
                infoDesc : "전송 과정: 아날로그 데이터 - 표본화 - 양자화 - 부호화 - 복호화 - 여과 - 아날로그 데이터",
            },
            {
                infoDate : "2019년 상시",
                infoType : "정보처리기능사",
                infoQuestion : "다음 중 변복조기(Modem)의 변복조 방식이 아닌 것은?",
                infoChoice : {
                    1: "주파수 편이 변조",
                    2: "진폭 편이 변조",
                    3: "평균 전압 편이 변조",
                    4: "위상 편이 변조",
                },
                infoAnswer : "3",
                infoDesc : "주파수 편이 변조(FSK; Frequency Shift Keying): 2진수 0과 1에 서로 다른 주파수를 적용하여 변조<br>진폭 편이 변조(ASK; Amplitude Shift Keying): 2진수 0과 1에 서로 다른 진폭을 적용하여 변조<br>위상 편이 변조(PSK; Phase Shift Keying): 2진수 0과 1에 서로 다른 위상을 적용하여 전송<br>진목 위상 변조(QAM; Quadrature Amplitude Modulation): 2진수 0과 1에 진폭과 위상을 변조하여 전송",
            },
            {
                infoDate : "2020년 4회",
                infoType : "정보처리기능사",
                infoQuestion : "에러 검출 후 재전송(ARQ) 에러 제어 방식에 속하지 않는 것은?",
                infoChoice : {
                    1: "Stop-and-Wait",
                    2: "Go-back-N",
                    3: "선택적 재전송",
                    4: "전진 에러 수정(FEC)",
                },
                infoAnswer : "4",
                infoDesc : "자동 재전송 방식(ARQ; Automatic Repeat reQuest): 정지-대기 ARQ(Stop & Wait ARQ), Go-back-N ARQ, 선택적 ARQ(Selective ARQ), 적응적(Adaptive) ARQ",
            },
            {
                infoDate : "2018년 상시",
                infoType : "정보처리기능사",
                infoQuestion : "OSI 7계층 참조 모델에서 하위 계층에 속하지 않는 것은?",
                infoChoice : {
                    1: "물리 계층",
                    2: "데이터 링크 계층",
                    3: "네트워크 계층",
                    4: "트랜스포트 계층",
                },
                infoAnswer : "4",
                infoDesc : "하위층<br>1계층 - 물리 계층 : 매체 접근에 따른 기계적, 전기적, 물리적 절차를 규정<br>2계층 - 데이터 링크 계층 : 인접 개방형 시스템 간의 정보 전송 및 오류 제어<br>3계층 - 네트워크 계층 : 정보 교환, 중계 기능, 경로 선정, 유통 제어 등<br>4계층 - 전송 계층 : 송수신 시스템 간의 논리적 안정 및 균등한 서비스 제공<br>상위층<br>5계층 - 세션 계층 : 응용 프로세스 간의 연결 접속 및 동기 제어 기능<br>6계층 - 표현 계층 : 정보의 형식 설정 및 부호 교환, 암호화, 해독, 압축 등<br>7계층 - 응용 계층 : 응용 프로세스 간의 정보 교환 및 전자 사서함, 파일 전송 등<br>※ 전송 계층을 상위층으로 포함하여 구분하는 경우도 있음",
            },
        ];

        // 문제 출력
        const updateQuiz = () => {
            const quizArray = [];
        
            quizInfo.forEach((quiz, index) => {
                quizArray.push(`
                    <div class="quiz">
                        <div class="quiz__header">${quiz.infoDate} ${quiz.infoType}</div>
                        <div class="quiz__main">
                            <div class="quiz__question">${index+1}. ${quiz.infoQuestion}</div>
                            <div class="quiz__choice">
                                <label for="choice1-${index}">
                                    <input type="radio" id="choice1-${index}" name="choice${index}" value="1">
                                    <span>${quiz.infoChoice[1]}</span>
                                </label>
                                <label for="choice2-${index}">
                                    <input type="radio" id="choice2-${index}" name="choice${index}" value="2">
                                    <span>${quiz.infoChoice[2]}</span>
                                </label>
                                <label for="choice3-${index}">
                                    <input type="radio" id="choice3-${index}" name="choice${index}" value="3">
                                    <span>${quiz.infoChoice[3]}</span>
                                </label>
                                <label for="choice4-${index}">
                                    <input type="radio" id="choice4-${index}" name="choice${index}" value="4">
                                    <span>${quiz.infoChoice[4]}</span>
                                </label>
                            </div>
                            <div class="quiz__answer none">${quiz.infoAnswer}</div>
                            <div class="quiz__desc none">${quiz.infoDesc}</div>
                        </div>
                        <div class="quiz__footer">
                            <button class="quiz__confirm" data-index="${index}">정답 확인하기</button>
                        </div>
                    </div>
                `);
            });

            quizWrap.innerHTML = quizArray.join(" ");
        }
        
        // 정답 확인
        const answerQuiz = (index) => {
            const quizChoices = document.querySelectorAll(`.quiz__choice input[name="choice${index}"]:checked`);
            const answerElement = quizWrap.querySelectorAll(".quiz__answer")[index];
            const descElement = quizWrap.querySelectorAll(".quiz__desc")[index];
            const quizElement = quizWrap.querySelectorAll(".quiz")[index];

            if (quizChoices.length > 0) {
                const userAnswer = quizChoices[0].value;

                if (userAnswer === quizInfo[index].infoAnswer) {
                    answerElement.textContent = "정답입니다!";
                    quizElement.classList.add("good");
                    totalScore++;
                    quizScore.innerHTML = totalScore;
                } else {
                    answerElement.textContent = "오답입니다!";
                    quizElement.classList.add("bad");
                    descElement.classList.remove("none");
                }
            }
        }

        // 페이지가 로드된 후 실행
        document.addEventListener("DOMContentLoaded", () => {
            updateQuiz();

            const confirmButtons = document.querySelectorAll(".quiz__confirm");
            confirmButtons.forEach((button, index) => {
                button.addEventListener("click", () => {
                    answerQuiz(index);
                });
            });
        });

    
    </script>
</body>
</html>